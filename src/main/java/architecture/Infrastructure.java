package architecture;

/**
 * DDD 可以支撑多种架构
 *
 * 1、依赖注入
 *  1.1 参考贲目录下 ddd依赖注入架构.png
 *  1.2 在领域层中定义资源库的接口，然后在基础设施层中实现该接口
 *  1.3 事实上，当我们用到依赖倒置原则时，已不存在分层概念了，无论是高层还是底层，都依赖于抽象，就好像把整个架构摊平了一样
 *      补充依赖倒置原则: 上层模块不应该依赖底层模块,它们都应该依赖于抽象,抽象不应该依赖于细节,细节应该依赖于抽象
 *
 * 2、六边形架构
 *  2.1 分成两个区域: 外部区域(提交不同的用户输入)，内部区域(用于获取持久化数据，输出，存储，如数据库)
 *  2.2 六边形每条不同的边代表不同种类型的端口，可以是 http, rpc, MQ 等
 *  2.3 在使用六边形架构时，我们应该根据用例来设计程序，提供统一的 API，因为用户可能是通过 RCP 访问，或 HTTP 访问，或 MQ 访问
 *  2.4 六边形架构可以用来支持其他架构，比如 SOA(Service Oriented Architechture), REST, 时间驱动，CQRS, 甚至 Map-reduce 分布式架构
 *
 * 3、SOA（Service Oriented Architecture）
 *  3.1 SOA 遵循服务设计原则，需要服务契约，松耦合，服务抽象，服务重用性，服务自治性，服务无状态，服务可发现性，服务组合性
 *  3.2 可以将 SOA 的这些设计原则与六边形架构结合起来，如图"SOA-DDD"所示，一个六边形架构支持多种服务端点，这个是依赖DDD是如何应用于SOA的
 *  3.3 SOA 服务可作为 REST 资源，SOAP(Simple Object Access Protocol)接口或者消息类型
 *
 * 4、Restful
 *  4.1 我们不建议将领域模型直接暴露给外界，可以在核心领域和系统接口模型之间完成解耦，用DTO对外传数据
 *  4.2 HTTP + DDD 的结合具有很好的松耦合和可伸缩的特性
 *
 * 5、CQRS（Command Query Responsibility Segregation）
 *  5.1 命令查询，职责分离，如果一个方法修改了对象的状态，该方法便是一个命令(Command)，它不应该返回数据，即 void
 *  5.2 如果有个方法返回了数据，该方法便是一个查询(Query)，此时它不应该通过直接的或间接的手段，修改对象的状态。
 *  5.3 读写通过事件订阅具有最终一致性 eg.CQRS读写分离.png
 *  5.4 对于事件的延时，我们还可以采用"观察者"，"分布式缓存/分布式网格"的事件订阅
 *  5.5 CQRS 融入六边形架构
 *
 * 6、数据网格(也称网格计算)和基于网格的分布式计算
 *  6.1 网格计算是分布式计算的一种，是一门计算机科学。它研究如何把一个需要非常巨大的计算能力才能解决的问题分成许多小的部分，
 *      然后把这些部分分配给许多计算机进行处理，最后把这些计算结果综合起来得到最终结果
 *  6.2 网格计算能够很好地在技术层面上与领域保持一致，从而在很大程度上缩短开发周期
 *
 * 7、事件驱动网格和领域事件
 *  7.1 大部分网格计算具有内部计算事件，这些时间不应该与领域事件混淆
 *
 */
public class Infrastructure {
}
